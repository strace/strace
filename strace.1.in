.\" Copyright (c) 1991, 1992 Paul Kranenburg <pk@cs.few.eur.nl>
.\" Copyright (c) 1993 Branko Lankester <branko@hacktic.nl>
.\" Copyright (c) 1993, 1994, 1995, 1996 Rick Sladkey <jrs@world.std.com>
.\" Copyright (c) 1996-2017 The strace developers.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.de CW
.sp
.in +4n
.nf
.ft CW
..
.de CE
.ft R
.fi
.in
.sp
..
.\" Like .OP, but with ellipsis at the end in order to signify that option
.\" can be provided multiple times. Based on .OP definition in groff's
.\" an-ext.tmac.
.de OM
.  ie \\n(.$-1 \
.    RI "[\fB\\$1\fP" "\ \\$2" "]...\&"
.  el \
.    RB "[" "\\$1" "]...\&"
..
.\" Required option.
.de OR
.  ie \\n(.$-1 \
.    RI "\fB\\$1\fP" "\ \\$2"
.  el \
.    BR "\\$1"
..
.de URL
\\$2 \(laURL: \\$1 \(ra\\$3
..
.if \n[.g] .mso www.tmac
.TH STRACE 1 "@MANPAGE_DATE@" "strace @VERSION@"
.SH NAME
strace \- trace system calls and signals
.SH SYNOPSIS
.SY strace
.OP \-CdffhikqrtttTvVxxy
.OP \-I n
.OP \-b execve
.OM \-e expr
.OP \-a column
.OP \-o file
.OP \-s strsize
.OM \-P path
.OM \-p pid
.BR "" {
.OR \-p pid
.BR "" |
.OP \-D
.OM \-E var\fR[=\fIval\fR]
.OP \-u username
.IR command " [" args ]
.BR "" }
.YS
.SY strace
.B \-c
.OP \-df
.OP \-I n
.OP \-b execve
.OM \-e expr
.OP \-O overhead
.OP \-S sortby
.OM \-P path
.OM \-p pid
.BR "" {
.OR \-p pid
.BR "" |
.OP \-D
.OM \-E var\fR[=\fIval\fR]
.OP -u username
.IR command " [" args ]
.BR "" }
.YS

.SH DESCRIPTION
.IX "strace command" "" "\fLstrace\fR command"
.LP
In the simplest case
.B strace
runs the specified
.I command
until it exits.
It intercepts and records the system calls which are called
by a process and the signals which are received by a process.
The name of each system call, its arguments and its return value
are printed on standard error or to the file specified with the
.B \-o
option.
.LP
.B strace
is a useful diagnostic, instructional, and debugging tool.
System administrators, diagnosticians and trouble-shooters will find
it invaluable for solving problems with
programs for which the source is not readily available since
they do not need to be recompiled in order to trace them.
Students, hackers and the overly-curious will find that
a great deal can be learned about a system and its system calls by
tracing even ordinary programs.  And programmers will find that
since system calls and signals are events that happen at the user/kernel
interface, a close examination of this boundary is very
useful for bug isolation, sanity checking and
attempting to capture race conditions.
.LP
Each line in the trace contains the system call name, followed
by its arguments in parentheses and its return value.
An example from stracing the command "cat /dev/null" is:
.CW
open("/dev/null", O_RDONLY) = 3
.CE
Errors (typically a return value of \-1) have the errno symbol
and error string appended.
.CW
open("/foo/bar", O_RDONLY) = \-1 ENOENT (No such file or directory)
.CE
Signals are printed as signal symbol and decoded siginfo structure.
An excerpt from stracing and interrupting the command "sleep 666" is:
.CW
sigsuspend([] <unfinished ...>
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=...} ---
+++ killed by SIGINT +++
.CE
If a system call is being executed and meanwhile another one is being called
from a different thread/process then
.B strace
will try to preserve the order of those events and mark the ongoing call as
being
.IR unfinished .
When the call returns it will be marked as
.IR resumed .
.CW
[pid 28772] select(4, [3], NULL, NULL, NULL <unfinished ...>
[pid 28779] clock_gettime(CLOCK_REALTIME, {1130322148, 939977000}) = 0
[pid 28772] <... select resumed> )      = 1 (in [3])
.CE
Interruption of a (restartable) system call by a signal delivery is processed
differently as kernel terminates the system call and also arranges its
immediate reexecution after the signal handler completes.
.CW
read(0, 0x7ffff72cf5cf, 1)              = ? ERESTARTSYS (To be restarted)
--- SIGALRM ... ---
rt_sigreturn(0xe)                       = 0
read(0, "", 1)                          = 0
.CE
Arguments are printed in symbolic form with a passion.
This example shows the shell performing ">>xyzzy" output redirection:
.CW
open("xyzzy", O_WRONLY|O_APPEND|O_CREAT, 0666) = 3
.CE
Here the third argument of open is decoded by breaking down the
flag argument into its three bitwise-OR constituents and printing the
mode value in octal by tradition.  Where traditional or native
usage differs from ANSI or POSIX, the latter forms are preferred.
In some cases,
.B strace
output has proven to be more readable than the source.
.LP
Structure pointers are dereferenced and the members are displayed
as appropriate.  In all cases arguments are formatted in the most C-like
fashion possible.
For example, the essence of the command "ls \-l /dev/null" is captured as:
.CW
lstat("/dev/null", {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
.CE
Notice how the 'struct stat' argument is dereferenced and how each member is
displayed symbolically.  In particular, observe how the st_mode member
is carefully decoded into a bitwise-OR of symbolic and numeric values.
Also notice in this example that the first argument to lstat is an input
to the system call and the second argument is an output.  Since output
arguments are not modified if the system call fails, arguments may not
always be dereferenced.  For example, retrying the "ls \-l" example
with a non-existent file produces the following line:
.CW
lstat("/foo/bar", 0xb004) = \-1 ENOENT (No such file or directory)
.CE
In this case the porch light is on but nobody is home.
.LP
Character pointers are dereferenced and printed as C strings.
Non-printing characters in strings are normally represented by
ordinary C escape codes.
Only the first
.I strsize
(32 by default) bytes of strings are printed;
longer strings have an ellipsis appended following the closing quote.
Here is a line from "ls \-l" where the
.B getpwuid
library routine is reading the password file:
.CW
read(3, "root::0:0:System Administrator:/"..., 1024) = 422
.CE
While structures are annotated using curly braces, simple pointers
and arrays are printed using square brackets with commas separating
elements.  Here is an example from the command "id" on a system with
supplementary group ids:
.CW
getgroups(32, [100, 0]) = 2
.CE
On the other hand, bit-sets are also shown using square brackets
but set elements are separated only by a space.  Here is the shell
preparing to execute an external command:
.CW
sigprocmask(SIG_BLOCK, [CHLD TTOU], []) = 0
.CE
Here the second argument is a bit-set of two signals, SIGCHLD and SIGTTOU.
In some cases the bit-set is so full that printing out the unset
elements is more valuable.  In that case, the bit-set is prefixed by
a tilde like this:
.CW
sigprocmask(SIG_UNBLOCK, ~[], NULL) = 0
.CE
Here the second argument represents the full set of all signals.
.SH OPTIONS
.SS Output format
.TP 12
.BI "\-a " column
Align return values in a specific column (default column 40).
.TP
.B \-i
Print the instruction pointer at the time of the system call.
.TP
.B \-k
Print the execution stack trace of the traced processes after each system call (experimental).
This option is available only if
.B strace
is built with libunwind.
.TP
.BI "\-o " filename
Write the trace output to the file
.I filename
rather than to stderr.
Use
.I filename.pid
if
.B \-ff
is used.
If the argument begins with '|' or with '!' then the rest of the
argument is treated as a command and all output is piped to it.
This is convenient for piping the debugging output to a program
without affecting the redirections of executed programs.
.TP
.B \-q
Suppress messages about attaching, detaching etc.  This happens
automatically when output is redirected to a file and the command
is run directly instead of attaching.
.TP
.B \-qq
If given twice, suppress messages about process exit status.
.TP
.B \-r
Print a relative timestamp upon entry to each system call.  This
records the time difference between the beginning of successive
system calls.
.TP
.BI "\-s " strsize
Specify the maximum string size to print (the default is 32).  Note
that filenames are not considered strings and are always printed in
full.
.TP
.B \-t
Prefix each line of the trace with the time of day.
.TP
.B \-tt
If given twice, the time printed will include the microseconds.
.TP
.B \-ttt
If given thrice, the time printed will include the microseconds
and the leading portion will be printed as the number
of seconds since the epoch.
.TP
.B \-T
Show the time spent in system calls.  This records the time
difference between the beginning and the end of each system call.
.TP
.B \-x
Print all non-ASCII strings in hexadecimal string format.
.TP
.B \-xx
Print all strings in hexadecimal string format.
.TP
.B \-y
Print paths associated with file descriptor arguments.
.TP
.B \-yy
Print protocol specific information associated with socket file descriptors.
.SS Statistics
.TP 12
.B \-c
Count time, calls, and errors for each system call and report a summary on
program exit.  On Linux, this attempts to show system time (CPU time spent
running in the kernel) independent of wall clock time.  If
.B \-c
is used with
.B \-f
or
.B \-F
, only aggregate totals for all traced processes are kept.
.TP
.B \-C
Like
.B \-c
but also print regular output while processes are running.
.TP
.BI "\-O " overhead
Set the overhead for tracing system calls to
.I overhead
microseconds.
This is useful for overriding the default heuristic for guessing
how much time is spent in mere measuring when timing system calls using
the
.B \-c
option.  The accuracy of the heuristic can be gauged by timing a given
program run without tracing (using
.BR time (1))
and comparing the accumulated
system call time to the total produced using
.BR \-c .
.TP
.BI "\-S " sortby
Sort the output of the histogram printed by the
.B \-c
option by the specified criterion.  Legal values are
.BR time ,
.BR calls ,
.BR name ,
and
.B nothing
(default is
.BR time ).
.TP
.B \-w
Summarise the time difference between the beginning and end of
each system call.  The default is to summarise the system time.
.SS Filtering
.TP 12
.BI "\-e " expr
A qualifying expression which modifies which events to trace
or how to trace them.  The format of the expression is:
.RS 15
.IP
[\,\fIqualifier\/\fB=\fR][\fB!\fR][\fB?\fR]\,\fIvalue1\/\fR[\fB,\fR[\fB?\fR]\,\fIvalue2\/\fR]...
.RE
.IP
where
.I qualifier
is one of
.BR trace ,
.BR abbrev ,
.BR verbose ,
.BR raw ,
.BR signal ,
.BR read ,
.BR write ,
.BR fault ,
or
.B inject
and
.I value
is a qualifier-dependent symbol or number.  The default
qualifier is
.BR trace .
Using an exclamation mark negates the set of values.  For example,
.BR \-e "\ " open
means literally
.BR \-e "\ " trace = open
which in turn means trace only the
.B open
system call.  By contrast,
.BR \-e "\ " trace "=!" open
means to trace every system call except
.BR open .
Question mark before the syscall qualification allows suppression of error
in case no syscalls matched the qualification provided.
In addition, the special values
.B all
and
.B none
have the obvious meanings.
.IP
Note that some shells use the exclamation point for history
expansion even inside quoted arguments.  If so, you must escape
the exclamation point with a backslash.
.TP
\fB\-e\ trace\fR=\,\fIset\fR
Trace only the specified set of system calls.  The
.B \-c
option is useful for determining which system calls might be useful
to trace.  For example,
.BR trace = open,close,read,write
means to only
trace those four system calls.  Be careful when making inferences
about the user/kernel boundary if only a subset of system calls
are being monitored.  The default is
.BR trace = all .
.TP
\fB\-e\ trace\fR=/\,\fIregex\fR
Trace only those system calls that match the
.IR regex .
You can use
.B POSIX
Extended Regular Expression syntax (see
.BR regex (7)).
.PP
.BR "\-e\ trace" = %file
.TQ
.BR "\-e\ trace" = file " (deprecated)"
Trace all system calls which take a file name as an argument.  You
can think of this as an abbreviation for
.BR "\-e\ trace" = open , stat , chmod , unlink ,...
which is useful to seeing what files the process is referencing.
Furthermore, using the abbreviation will ensure that you don't
accidentally forget to include a call like
.B lstat
in the list.  Betchya woulda forgot that one.
.PP
.BR "\-e\ trace" = %process
.TQ
.BR "\-e\ trace" = process " (deprecated)"
Trace all system calls which involve process management.  This
is useful for watching the fork, wait, and exec steps of a process.
.PP
.BR "\-e\ trace" = %network
.TQ
.BR "\-e\ trace" = network " (deprecated)"
Trace all the network related system calls.
.PP
.BR "\-e\ trace" = %signal
.TQ
.BR "\-e\ trace" = signal " (deprecated)"
Trace all signal related system calls.
.PP
.BR "\-e\ trace" = %ipc
.TQ
.BR "\-e\ trace" = ipc " (deprecated)"
Trace all IPC related system calls.
.PP
.BR "\-e\ trace" = %desc
.TQ
.BR "\-e\ trace" = desc " (deprecated)"
Trace all file descriptor related system calls.
.PP
.BR "\-e\ trace" = %memory
.TQ
.BR "\-e\ trace" = memory " (deprecated)"
Trace all memory mapping related system calls.
.TP
.BR "\-e\ trace" = %stat
Trace stat syscall variants.
.TP
.BR "\-e\ trace" = %lstat
Trace lstat syscall variants.
.TP
.BR "\-e\ trace" = %fstat
Trace fstat and fstatat syscall variants.
.TP
.BR "\-e\ trace" = %%stat
Trace syscalls used for requesting file status (stat, lstat, fstat, fstatat,
statx, and their variants).
.TP
.BR "\-e\ trace" = %statfs
Trace statfs, statfs64, statvfs, osf_statfs, and osf_statfs64 system calls.
The same effect can be achieved with
.BR "\-e\ trace" = /^(.*_)?statv?fs
regular expression.
.TP
.BR "\-e\ trace" = %fstatfs
Trace fstatfs, fstatfs64, fstatvfs, osf_fstatfs, and osf_fstatfs64 system calls.
The same effect can be achieved with
.BR "\-e\ trace" = /fstatv?fs
regular expression.
.TP
.BR "\-e\ trace" = %%statfs
Trace syscalls related to file system statistics (statfs-like, fstatfs-like,
and ustat).  The same effect can be achieved with
.BR "\-e\ trace" = /statv?fs|fsstat|ustat
regular expression.
.TP
\fB\-e\ abbrev\fR=\,\fIset\fR
Abbreviate the output from printing each member of large structures.
The default is
.BR abbrev = all .
The
.B \-v
option has the effect of
.BR abbrev = none .
.TP
\fB\-e\ verbose\fR=\,\fIset\fR
Dereference structures for the specified set of system calls.  The
default is
.BR verbose = all .
.TP
\fB\-e\ raw\fR=\,\fIset\fR
Print raw, undecoded arguments for the specified set of system calls.
This option has the effect of causing all arguments to be printed
in hexadecimal.  This is mostly useful if you don't trust the
decoding or you need to know the actual numeric value of an
argument.
.TP
\fB\-e\ signal\fR=\,\fIset\fR
Trace only the specified subset of signals.  The default is
.BR signal = all .
For example,
.B signal "=!" SIGIO
(or
.BR signal "=!" io )
causes SIGIO signals not to be traced.
.TP
\fB\-e\ read\fR=\,\fIset\fR
Perform a full hexadecimal and ASCII dump of all the data read from
file descriptors listed in the specified set.  For example, to see
all input activity on file descriptors
.I 3
and
.I 5
use
\fB\-e\ read\fR=\,\fI3\fR,\fI5\fR.
Note that this is independent from the normal tracing of the
.BR read (2)
system call which is controlled by the option
.BR -e "\ " trace = read .
.TP
\fB\-e\ write\fR=\,\fIset\fR
Perform a full hexadecimal and ASCII dump of all the data written to
file descriptors listed in the specified set.  For example, to see
all output activity on file descriptors
.I 3
and
.I 5
use
\fB\-e\ write\fR=\,\fI3\fR,\,\fI5\fR.
Note that this is independent from the normal tracing of the
.BR write (2)
system call which is controlled by the option
.BR -e "\ " trace = write .
.TP
\fB\-e\ inject\fR=\,\fIset\/\fR[:\fBerror\fR=\,\fIerrno\/\fR|:\fBretval\fR=\,\fIvalue\/\fR][:\fBsignal\fR=\,\fIsig\/\fR][:\fBwhen\fR=\,\fIexpr\/\fR]
Perform syscall tampering for the specified set of syscalls.

At least one of
.BR error ,
.BR retval ,
or
.B signal
options has to be specified.
.B error
and
.B retval
are mutually exclusive.

If :\fBerror\fR=\,\fIerrno\/\fR option is specified,
a fault is injected into a syscall invocation:
the syscall number is replaced by -1 which corresponds to an invalid syscall,
and the error code is specified using a symbolic
.I errno
value like
.B ENOSYS
or a numeric value within 1..4095 range.

If :\fBretval\fR=\,\fIvalue\/\fR option is specified,
success injection is performed: the syscall number is replaced by -1,
but a bogus success value is returned to the callee.

If :\fBsignal\fR=\,\fIsig\/\fR option is specified with either a symbolic value
like
.B SIGSEGV
or a numeric value within 1..\fBSIGRTMAX\fR range,
that signal is delivered on entering every syscall specified by the
.IR set .

If :\fBsignal\fR=\,\fIsig\/\fR option is specified without
:\fBerror\fR=\,\fIerrno\/\fR or :\fBretval\fR=\,\fIvalue\/\fR options,
then only a signal
.I sig
is delivered without a syscall fault injection.
Conversely, :\fBerror\fR=\,\fIerrno\/\fR or
:\fBretval\fR=\,\fIvalue\/\fR option without
:\fBsignal\fR=\,\fIsig\/\fR option injects a fault without delivering a signal.

If both :\fBerror\fR=\,\fIerrno\/\fR or :\fBretval\fR=\,\fIvalue\/\fR
and :\fBsignal\fR=\,\fIsig\/\fR options are specified, then both
a fault or success is injected and a signal is delivered.

Unless a :\fBwhen\fR=\,\fIexpr\fR subexpression is specified,
an injection is being made into every invocation of each syscall from the
.IR set .

The format of the subexpression is one of the following:
.RS
.IP "" 2
.I first
.RS 4
For every syscall from the
.IR set ,
perform an injection for the syscall invocation number
.I first
only.
.RE
.IP "" 2
\fIfirst\/\fB+\fR
.RS 4
For every syscall from the
.IR set ,
perform injections for the syscall invocation number
.I first
and all subsequent invocations.
.RE
.IP "" 2
\fIfirst\/\fB+\fIstep\fR
.RS 4
For every syscall from the
.IR set ,
perform injections for syscall invocations number
.IR first ,
.IR first + step ,
.IR first + step + step ,
and so on.
.RE
.RE
.IP
For example, to fail each third and subsequent chdir syscalls with
.BR ENOENT ,
use
\fB\-e\ inject\fR=\,\fIchdir\/\fR:\fBerror\fR=\,\fIENOENT\/\fR:\fBwhen\fR=\,\fI3\/\fB+\fR.

The valid range for numbers
.I first
and
.I step
is 1..65535.

An injection expression can contain only one
.BR error =
or
.BR retval =
specification, and only one
.BR signal =
specification.  If an injection expression contains multiple
.BR when =
specifications, the last one takes precedence.

Accounting of syscalls that are subject to injection
is done per syscall and per tracee.

Specification of syscall injection can be combined
with other syscall filtering options, for example,
\fB\-P \fI/dev/urandom \fB\-e inject\fR=\,\fIfile\/\fR:\fBerror\fR=\,\fIENOENT\fR.

.TP
\fB\-e\ fault\fR=\,\fIset\/\fR[:\fBerror\fR=\,\fIerrno\/\fR][:\fBwhen\fR=\,\fIexpr\/\fR]
Perform syscall fault injection for the specified set of syscalls.

This is equivalent to more generic
\fB\-e\ inject\fR= expression with default value of
.I errno
option set to
.IR ENOSYS .

.TP
.BI "\-P " path
Trace only system calls accessing
.IR path .
Multiple
.B \-P
options can be used to specify several paths.
.TP
.B \-v
Print unabbreviated versions of environment, stat, termios, etc.
calls.  These structures are very common in calls and so the default
behavior displays a reasonable subset of structure members.  Use
this option to get all of the gory details.
.SS Tracing
.TP 12
.BI "\-b " syscall
If specified syscall is reached, detach from traced process.
Currently, only
.I execve
syscall is supported.  This option is useful if you want to trace
multi-threaded process and therefore require -f, but don't want
to trace its (potentially very complex) children.
.TP
.B \-D
Run tracer process as a detached grandchild, not as parent of the
tracee.  This reduces the visible effect of
.B strace
by keeping the tracee a direct child of the calling process.
.TP
.B \-f
Trace child processes as they are created by currently traced
processes as a result of the
.BR fork (2),
.BR vfork (2)
and
.BR clone (2)
system calls.  Note that
.B \-p
.I PID
.B \-f
will attach all threads of process PID if it is multi-threaded,
not only thread with thread_id = PID.
.TP
.B \-ff
If the
.B \-o
.I filename
option is in effect, each processes trace is written to
.I filename.pid
where pid is the numeric process id of each process.
This is incompatible with
.BR \-c ,
since no per-process counts are kept.
.TP
.BI "\-I " interruptible
When strace can be interrupted by signals (such as pressing ^C).
1: no signals are blocked; 2: fatal signals are blocked while decoding syscall
(default); 3: fatal signals are always blocked (default if '-o FILE PROG');
4: fatal signals and SIGTSTP (^Z) are always blocked (useful to make
strace -o FILE PROG not stop on ^Z).
.SS Startup
.TP 12
\fB\-E\ \fIvar\fR=\,\fIval\fR
Run command with
.IR var = val
in its list of environment variables.
.TP
.BI "\-E " var
Remove
.IR var
from the inherited list of environment variables before passing it on to
the command.
.TP
.BI "\-p " pid
Attach to the process with the process
.SM ID
.I pid
and begin tracing.
The trace may be terminated
at any time by a keyboard interrupt signal (\c
.SM CTRL\s0-C).
.B strace
will respond by detaching itself from the traced process(es)
leaving it (them) to continue running.
Multiple
.B \-p
options can be used to attach to many processes in addition to
.I command
(which is optional if at least one
.B \-p
option is given).
.B \-p
"`pidof PROG`" syntax is supported.
.TP
.BI "\-u " username
Run command with the user \s-1ID\s0, group \s-2ID\s0, and
supplementary groups of
.IR username .
This option is only useful when running as root and enables the
correct execution of setuid and/or setgid binaries.
Unless this option is used setuid and setgid programs are executed
without effective privileges.
.SS Miscellaneous
.TP 12
.B \-d
Show some debugging output of
.B strace
itself on the standard error.
.TP
.B \-F
This option is now obsolete and it has the same functionality as
.BR \-f .
.TP
.B \-h
Print the help summary.
.TP
.B \-V
Print the version number of
.BR strace .
.SH LUA SCRIPTING
If built with Lua support,
.B strace
can execute Lua scripts.
A script file is passed to the
.B -l
option.
.PP
.B strace
provides the built-in module
.B strace
to the Lua execution environment, which contains various functions and
constants.
.PP
Before any tracing takes place, the script is run.
At this stage, it can do one of the following two things:
.RS
.IP \(bu 3
Implement its own tracing loop by selecting syscalls it wants to be notified
about with
.BR strace.C.monitor / strace.C.monitor_all
and calling
.B strace.next_sc
in a loop until it returns
.B nil
(or return earlier; in this case, the installed hooks for the remaining syscalls
are run).
.IP \(bu
Install syscall and at-exit hooks with
.BR strace.hook ", " strace.hook_class ", " strace.hook_scno " and " strace.at_exit .
.RE
.PP
Then,
.B strace
enters its own tracing loop, and all the installed hooks are run.
.SS Personalities
A personality is an execution domain with its own sets of syscalls, signals and
errors.
A
.I personality number
is strace-specific 0-based index in the architecture-dependent list of
personalities.
.SS FFI
.URL http://luajit.org/ext_ffi.html "FFI library"
is an extension provided by LuaJIT;
.URL https://github.com/jmckaskill/luaffi luaffi
and
.URL https://github.com/facebook/luaffifb luaffifb
standalone implementations are also supported, but only for Lua 5.2.
.PP
.B strace
provides the following FFI definitions:
.CW
typedef /* implementation-defined signed integer type   */ kernel_long_t;
typedef /* implementation-defined unsigned integer type */ kernel_ulong_t;

typedef struct sysent {
    unsigned nargs;          /* Number of arguments */
    int sys_flags;           /* Flags.  Currently, only meaningful in the
                              * context of struct syscall_class::value field:
                              * a syscall belongs to a class iff
                              * (class.value & syscall.sys_flags) != 0. */
    const char *sys_name;    /* Name */
} struct_sysent;

struct syscall_class {
    const char *name;        /* Name */
    unsigned int value;      /* Flag bit, see the comment on struct
                              * sysent::sys_flags field. */
};

typedef struct ioctlent {
    const char *symbol;
    unsigned int code;
} struct_ioctlent;

/* Trace control block */
struct tcb {
    int pid;                              /* Tracee's PID */
    unsigned long u_error;                /* Error code */
    kernel_ulong_t scno;                  /* System call number */
    kernel_ulong_t u_arg[/* MAX_ARGS */]; /* System call arguments */
    kernel_ulong_t u_rval;                /* Return value */
    unsigned int currpers;                /* Current personality */
};
.CE
.SS strace module: C submodule: functions
Note: be careful with boxed boolean values and use
.B not not
.I boxed_bool
when in doubt.
In particular, an
.B assert
on a boxed boolean will never raise an error.
.TP
\fIstatus\fR = \fBstrace.C.monitor\fR(\fIscno\fR, \fIpers\fR, \fIon_entry\fR, \fIon_exit\fR)
C type:
.B bool (*)(unsigned int, unsigned int, bool, bool)
.IP
Marks the syscall with number
.I scno
on personality
.I pers
as to be returned from
.BR strace.next_sc .
If
.I on_entry
is
.BR true ,
it is marked as to be returned on syscall entry, and if
.I on_exit
is
.BR true ,
it is marked as to be returned on syscall exit.
.IP
Note that this "marking" is a one-way process, and specifying
.B false
as any of the flags does not undo any previous calls to
.BR strace.C.monitor / strace.C.monitor_all .
.IP
Returns
.B true
on success and
.B false
on failure.
.TP
\fBstrace.C.monitor_all\fR(\fIon_entry\fR, \fIon_exit\fR)
C type:
.B void (*)(bool, bool)
.IP
Marks all syscalls on all personalities as to be returned from
.BR strace.next_sc :
on syscall entry if
.I on_entry
is
.BR true ,
and on syscall exit if
.I on_exit
is
.BR true .
See the note for
.BR strace.C.monitor .
.TP
\fIstatus\fR = \fBstrace.C.inject_signo\fR(\fIsigno\fR)
C type:
.B bool (*)(int)
.IP
Delivers a signal with number
.I signo
to the current tracee.
.IP
Note that this must be done on syscall entry.
.IP
Returns
.B true
on success and
.B false
on failure.
.TP
\fIstatus\fR = \fBstrace.C.inject_retval\fR(\fIval\fR)
C type:
.B bool (*)(int)
.IP
Injects a return value to the current syscall invocation.
.IP
Note that this must be done on syscall entry.
.IP
Returns
.B true
on success and
.B false
on failure.
.TP
\fIstatus\fR = \fBstrace.C.umove\fR(\fIaddr\fR, \fIlen\fR, \fIladdr\fR)
C type:
.B int (*)(kernel_ulong_t, size_t, void *)
.IP
Copies ("moves")
.I len
bytes of data from the current tracee process at address
.I addr
to a local address
.IR laddr .
.IP
Returns 0 on success and \-1 on failure.
.TP
\fIstatus\fR = \fBstrace.C.umove_str\fR(\fIaddr\fR, \fIlen\fR, \fIladdr\fR)
C type:
.B int (*)(kernel_ulong_t, size_t, char *)
.IP
Like
.BR strace.C.umove ,
but makes the additional effort of looking for a terminating zero byte.
Returns a negative value on failure, a positive value if a NUL was seen, and 0
if
.I len
bytes were read but no NUL seen.
.IP
Note: there is no guarantee it won't overwrite some bytes in \fIladdr\fR after
terminating NUL (but, of course, it never writes past
.IR laddr[len-1] ).
.TP
\fIstatus\fR = \fBstrace.C.upoke\fR(\fIaddr\fR, \fIlen\fR, \fIladdr\fR)
C type:
.B int (*)(kernel_ulong_t, size_t, const void *)
.IP
Copies ("pokes")
.I len
bytes of data from the local address
.I laddr
to the address
.I addr
of the current tracee process' address space.
.IP
Returns 0 on success and \-1 on failure.
.TP
\fIstatus\fR = \fBstrace.C.path_match\fR(\fIset\fR, \fInset\fR)
C type:
.B bool (*)(const char **, size_t)
.IP
Returns
.B true
if the current syscall accesses one of the paths from a given set of paths, and
.B false
otherwise.
.IP
Note: for string path arguments, the path is compared against the set; for file
descriptor arguments, the absolute path to the file behind the file descriptor
is compared against the set.
.SS strace module: C submodule: constants
.TP
.B strace.C.sysent_vec
Array of syscall tables for each of the supported personalities.
\fBstrace.C.sysent_vec\fR[\fIpers\fR][\fIscno\fR] is a
.B struct_sysent
for syscall number
.I scno
on personality
.IR pers .
May contain null entries (which have a NULL
.B sys_name
field).
.TP
.B strace.C.errnoent_vec
Array of error name tables for each of the supported personalities.
\fBstrace.C.errnoent_vec\fR[\fIpers\fR][\fIerrno\fR] is either a null pointer or
a C string with the name of error
.I errno
on personality
.IR pers .
.TP
.B strace.C.signalent_vec
Array of signal name tables for each of the supported personalities.
\fBstrace.C.signalent_vec\fR[\fIpers\fR][\fIsigno\fR] is either a null pointer
or a C string with the name of signal
.I signo
on personality
.IR pers .
.TP
.B strace.C.ioctlent_vec
Arrays of sorted known ioctl symbols, sorted by code, for each of the supported
personalities.
\fBstrace.C.ioctlent_vec\fR[\fIpers\fR][\fIi\fR] is the
.IR i \-th,
ranked by code,
.B struct_ioctlent
for personality
.IR pers .
.TP
.B strace.C.nsysent_vec
.TQ
.B strace.C.nerrnoent_vec
.TQ
.B strace.C.nsignalent_vec
.TQ
.B strace.C.nioctlent_vec
These are
.BR strace.npersonalities \-sized
arrays containing sizes of subarrays of
.BR strace.C.sysent_vec ,
.BR strace.C.errnoent_vec ,
.BR strace.C.signalent_vec " and"
.BR strace.C.ioctlent_vec ,
respectively.
.TP
.B strace.C.syscall_classes
Array of
.BR "struct syscall_class" ,
with a terminating null entry (which has a NULL
.B name
field).
.TP
.B strace.C.pers_name
A
.BR strace.npersonalities \-sized
array of C strings with names for each personality.
.TP
.B strace.C.pers_wordsize
.TQ
.B strace.C.pers_klongsize
These are
.BR strace.npersonalities \-sized
arrays with word and
.I __kernel_long_t
sizes for each personality.
.SS strace module: functions
Glossary:
.RS
.IP \(bu 3
an
.I integer
means either an integer Lua number or a cdata integer type;
.IP \(bu
a
.I boolean
means either a Lua boolean or a cdata
.BR bool ;
.IP \(bu
a
.I string
means either a Lua string or a cdata C string.
.RE
.PP
General conventions:
.RS
.IP \(bu 3
a
.I pers
argument is an
.I integer
specifying personality number;
.IP \(bu
an
.I addr
argument is a cdata
.IR kernel_ulong_t .
.RE
.TP
\fItcp\fR = \fBstrace.next_sc\fR()
If this is not the first call to this function, performs tracing and tampering
of the previously returned syscall.
.IP
Waits for the next monitored syscall to happen, and returns a pointer to its
trace control block.
This pointer is not persistent across different calls to this function and/or
hook calls.
.IP
If
.B strace
needs to be terminated (e.g. last tracee has been terminated, or
.B strace
has been interrupted), returns
.BR nil .
Once it returned
.BR nil ,
all subsequent calls to it will also return
.BR nil .
.TP
\fIstatus\fR = \fBstrace.entering\fR()
Returns
.B true
if this is a syscall entry, and
.B false
otherwise.
.TP
\fIstatus\fR = \fBstrace.exiting\fR()
Returns
.B true
if this is a syscall exit, and
.B false
otherwise.
.TP
\fBstrace.trace\fR([\fIflag\fR])
.TQ
\fBstrace.abbrev\fR([\fIflag\fR])
.TQ
\fBstrace.verbose\fR([\fIflag\fR])
.TQ
\fBstrace.raw\fR([\fIflag\fR])
These functions alter corresponding trace options.
.I flag
is a
.IR boolean ,
defaults to
.BR true .
.TP
\fIaddr\fR = \fBstrace.ptr_to_kulong\fR(\fIptr\fR)
Converts a cdata pointer to a
.B kernel_ulong_t
variable.
.TP
\fBstrace.at_exit\fR(\fIfunc\fR)
Registers a function
.I func
to be run when
.B strace
is going to terminate its execution.
.IP
If multiple exit callback functions are registered, they are run in the order
they were registered.
.TP
\fIname\fR = \fBstrace.get_sc_name\fR(\fIscno\fR, \fIpers\fR)
Returns syscall name as Lua string by its number for personality
.IR pers ,
or
.B nil
if
.I scno
is invalid.
.IP
.I scno
is an
.IR integer .
.TP
\fIname\fR = \fBstrace.get_sig_name\fR(\fIsigno\fR, \fIpers\fR)
Returns signal name (.e.g \fB"SIGSEGV"\fR) as Lua string by its number
.I signo
for personality
.IR pers ,
or
.B nil
if
.I signo
is invalid.
.TP
\fIname\fR = \fBstrace.get_err_name\fR(\fIerrno\fR, \fIpers\fR)
Returns error name (e.g. \fB"ENOENT"\fR) as Lua string by its error number
.I errno
for personality
.IR pers ,
or
.B nil
if
.I errno
is invalid.
.IP
.I errno
is an
.IR integer .
.TP
\fIname\fR = \fBstrace.get_ioctl_name\fR(\fIreqcode\fR, \fIpers\fR)
Returns ioctl symbol name (e.g. \fB"TIOCGWINSZ"\fR) as Lua string by its request
code
.I reqcode
for personality
.IR pers ,
or
.B nil
if
.I reqcode
is invalid.
.IP
.I reqcode
is an
.IR integer .
.TP
\fIscno\fR = \fBstrace.get_scno\fR(\fIscname\fR, \fIpers\fR)
Returns syscall number by its name for personality
.IR pers ,
or
.B nil
if no such syscall was found.
.IP
.I scname
is a
.IR string .
.TP
\fIsigno\fR = \fBstrace.get_signo\fR(\fIsigname\fR, \fIpers\fR)
Returns signal number by its name (e.g. \fB"SIGSEGV"\fR) for personality
.IR pers ,
or
.B nil
if no such signal was found.
.IP
.I signame
is
.IR string .
.TP
\fIerrno\fR = \fBstrace.get_errno\fR(\fIerrname\fR, \fIpers\fR)
Returns error number by its name (e.g. \fB"ENOENT"\fR) for personality
.IR pers ,
or
.B nil
if no such error was found.
.IP
.I errname
is a
.IR string .
.TP
\fIcode\fR = \fBstrace.get_ioctl_code\fR(\fIname\fR, \fIpers\fR)
Returns ioctl request code by its symbol name (e.g. \fB"TIOCGWINSZ"\fR) for
personality
.IR pers ,
or
.B nil
if no such ioctl request was found.
.IP
.I name
is a
.IR string .
.TP
\fIflagbit\fR = \fBstrace.get_class_flagbit\fR(\fIclsname\fR)
Returns the
.I value
field of the
.I struct syscall_class
structure
(see its definition in the
.B FFI
section above) corresponding to the syscall class with name
.IR clsname ,
or
.B nil
if such syscall class is invalid.
.I clsname
is a
.IR string .
.TP
\fIflags\fR = \fBstrace.get_sc_flags\fR(\fIscno\fR, \fIpers\fR)
Returns the
.I sys_flags
field of the
.I struct sysent
structure
(see its definition in the
.B FFI
section above)
corresponding to the syscall with number
.I scno
on personality
.IR pers ,
or
.B nil
if no such syscall exists.
.I scno
is an
.IR integer .
.TP
\fIstatus\fR[, \fIerr_msg\fR] = \fBstrace.inject_signal\fR(\fIsig\fR)
Delivers a signal to the tracee.
.I sig
is either signal number (an
.IR integer )
or name (a
.IR string ).
.IP
Returns
.B true
on success and
.B false
and an error message string on failure.
.IP
Note that this must be done on syscall entry.
.TP
\fIstatus\fR[, \fIerr_msg\fR] = \fBstrace.inject_retval\fR(\fIval\fR)
Injects a return value to the current syscall invocation.
.I val
is an
.IR integer .
.IP
Returns
.B true
on success and
.B false
and an error message string on failure.
.IP
Note that this must be done on syscall entry.
.TP
\fIstatus\fR[, \fIerr_msg\fR] = \fBstrace.inject_error\fR(\fIerr\fR)
Injects an error into a current syscall invocation.
.I err
is either error number (an
.IR integer )
or error name (a
.IR string ).
.IP
Returns
.B true
on success and
.B false
and an error message string on failure.
.IP
Note that this must be done on syscall entry.
.TP
\fIobj\fR = \fBstrace.read_obj\fR(\fIaddr\fR, \fIct\fR[, \fInelem\fR])
Reads an object of type
.I ct
from the current tracee process at address
.IR addr .
.I ct
is either a
.I cdecl
(a Lua string), a
.I cdata
serving as a template type, or a
.I ctype
(special kind of
.I cdata
returned by
.BR ffi.typeof ).
.IP
VLA/VLS types require the
.I nelem
argument (an
.IR integer ).
.IP
Returns an object on success and
.B nil
on failure.
.IP
Note that type sizes and structure paddings may differ from FFI's ones if
tracee's personality differs from
.BR strace 's
one.
.TP
\fIstr\fR[, \fIerr_msg\fR] = \fBstrace.read_str\fR(\fIaddr\fR[, \fImaxsz\fR[, \fIbufsz\fR]])
Reads a C string from the current tracee process at address
.I addr
using an intermediate buffer of size
.I bufsz
and stopping at
.I maxsz
bytes.
.IP
.I maxsz
and
.I bufsz
are
.IR integers .
.I maxsz
defaults to 4 Mb,
.I bufsz
to 1 Kb.
.IP
Returns a Lua string on success and
.B nil
and an error message string on failure.
.TP
\fIstr\fR[, \fIerr_msg\fR] = \fBstrace.read_path\fR(\fIaddr\fR)
Reads a path C string from the current tracee process at address
.IR addr ,
stopping at
.B PATH_MAX
bytes.
.IP
Returns a Lua string on success and
.B nil
and an error message string on failure.
.TP
\fIstatus\fR = \fBstrace.write_obj\fR(\fIaddr\fR, \fIobj\fR)
Writes a FFI cdata object
.I obj
to the address
.I addr
of the current tracee process's address space.
.IP
Returns
.B true
on success and
.B false
on failure.
.IP
See the note for
.BR strace.read_obj .
.TP
\fIstatus\fR = \fBstrace.hook\fR(\fIscname\fR, \fIwhen\fR, \fIcb\fR)
.TQ
\fIstatus\fR = \fBstrace.hook_class\fR(\fIclsname\fR, \fIwhen\fR, \fIcb\fR)
.TQ
\fIstatus\fR = \fBstrace.hook_scno\fR(\fIscno\fR, \fIpers\fR, \fIwhen\fR, \fIcb\fR)
These functions register a function
.I cb
to be run when a syscall with the given name (or with a name from a given set
thereof), belonging to a class with the given name (or with a name from a given
set thereof), or with the given number (or with a number from a given set
thereof) on personality
.IR pers ,
happens.
.IP
.I when
is either a two-element array (that is, a table with keys 1 and 2) with boolean
values, or a Lua string.
.I cb
is registered to be run:
.RS
.IP \(bu 3
on syscall entry if
.I when
is either
.B {true, false}
or \fB"entering"\fR;
.IP \(bu
on syscall exit if
.I when
is either
.B {false, true}
or \fB"exiting"\fR;
.IP \(bu
both on syscall entry and exit if
.I when
is either
.B {true, true}
or \fB"both"\fR;
.IP \(bu
at no time if
.I when
is
.B "{false, false}"
(in this case, a call is effectively ignored).
.RE
.IP
A pointer to the trace control block is passed as the only argument to
.IR cb .
This pointer is not persistent across
.B strace.next_sc
and/or another hook calls.
.IP
If multiple callback functions are registered for the same event (syscall entry
or exit), they are run in the order they were registered.
.IP
.IR scname " and " clsname
are either
.I strings
or tables thereof.
.I scno
is either an
.I integer
or a table thereof.
.IP
Return
.B true
on success and
.B false
on failure.
.TP
\fIstatus\fR = \fBstrace.path_match\fR(\fIset\fR)
Returns
.B true
if the current syscall accesses a given path, or one of the paths from the given
set of paths; and
.B false
otherwise (see the note for
.BR strace.C.path_match ).
.IP
.I set
is either a
.I string
or a table thereof.
.SS strace module: constants
.TP
.B strace.npersonalities
Number of supported personalities (an integer Lua number).
.TP
.B strace.max_args
Size of
.B struct tcb::u_arg
array (an integer Lua number).
.TP
.B strace.path_max
Value of
.B PATH_MAX
constant (an integer Lua number).
.SS Examples
The following script counts the number of processes (including threads) spawned
by the tracee.
Note that you would probably want to launch
.B strace
with
.B -f
option, so that children also be traced.
.CW
n = 0
assert(strace.hook({'clone', 'fork', 'vfork'}, 'exiting', function(tcp)
    if tcp.u_rval ~= -1 then
        n = n + 1
    end
end))
strace.at_exit(function() print('Processes spawned:', n) end)
.CE
If you have a C preprocessor installed, you can invoke it to pre-process local
and/or system headers.
However, using it this way, the only type of macros you can access is integer
constant macros (possibly expanding to a constant arithmetic expression: the FFI
library is able to evaluate them).
To do so, declare an enumeration member or a static constant of an appropriate
type with value being the result of expansion of the macro (see the following
example).
.PP
The following script injects the
.B EPERM
error to each
.B fcntl
(and
.BR fcntl64 )
syscall invocation with
.B F_SETPIPE_SZ
command.
.CW
ffi = require 'ffi'
f = assert(io.popen([[cpp - <<EOF | grep -v '^#'

#define _GNU_SOURCE
#include <fcntl.h>
enum { f_setpipe_sz = F_SETPIPE_SZ };

EOF]], 'r'))
ffi.cdef(f:read('*a'))
f:close()

assert(strace.hook({'fcntl', 'fcntl64'}, 'entering', function(tcp)
    if tcp.u_arg[1] == ffi.C.f_setpipe_sz then
        assert(strace.inject_error('EPERM'))
    end
end))
.CE
The following script reads the definition of a structure from a system header
file, and modifies one of its fields so that
.BR uname (1)
always prints out
.IR Windows .
.CW
ffi = require 'ffi'
f = assert(io.popen([[cpp - <<EOF | grep -v '^#'

#include <sys/utsname.h>

EOF]], 'r'))
ffi.cdef(f:read('*a'))
f:close()

assert(strace.hook('uname', 'exiting', function(tcp)
    if tcp.u_rval == -1 then
        return
    end

    local u = assert(strace.read_obj(tcp.u_arg[0], 'struct utsname'))

    local s = 'Windows'
    assert(ffi.sizeof(u.sysname) >= #s + 1)
    ffi.copy(u.sysname, s)

    assert(strace.write_obj(tcp.u_arg[0], u))
end))
.CE
Note that this does not work if the name of the structure or one of its field is
defined to something else.
In the case of the first, however, something like
.CW
typedef struct utsname struct_utsname;
.CE
should work.
.PP
To access other types of macros (namely, floating-point and strings constants,
and function macros), the
.URL https://github.com/umegaya/ffiex "ffiex library"
can be used.
The following example gathers statistics on exit codes of child processes that
have been waited for by the tracee with one of the appropriate syscalls with
non-NULL
.I status
argument.
.CW
ffiex = require 'ffiex'
ffiex.cdef[[
#include <sys/wait.h>
]]

function is_truthy(x)
    return x and x ~= 0
end

stats = {}

assert(strace.hook({'waitpid', 'wait4', 'osf_wait4'}, 'exiting', function(tcp)
    if tcp.u_rval == -1 or tcp.u_rval == 0 or tcp.u_arg[1] == 0 then
        return
    end
    local status = tonumber(assert(strace.read_obj(tcp.u_arg[1], 'int')))
    if is_truthy(ffiex.defs.WIFEXITED(status)) then
        local c = ffiex.defs.WEXITSTATUS(status)
        stats[c] = (stats[c] or 0) + 1
    end
end))

strace.at_exit(function()
    print('Exit codes:')
    for k, v in pairs(stats) do
        print(k .. ':', v)
    end
end)
.CE
Note that this does not work if the result of the expansion of the macro
contains something that can not be evaluated by
.BR ffiex ,
e.g. a call to a
.I static inline
function defined in the header.
.SH DIAGNOSTICS
When
.I command
exits,
.B strace
exits with the same exit status.
If
.I command
is terminated by a signal,
.B strace
terminates itself with the same signal, so that
.B strace
can be used as a wrapper process transparent to the invoking parent process.
Note that parent-child relationship (signal stop notifications,
getppid() value, etc) between traced process and its parent are not preserved
unless
.B \-D
is used.
.LP
When using
.B \-p
without a
.IR command ,
the exit status of
.B strace
is zero unless no processes has been attached or there was an unexpected error
in doing the tracing.
.SH "SETUID INSTALLATION"
If
.B strace
is installed setuid to root then the invoking user will be able to
attach to and trace processes owned by any user.
In addition setuid and setgid programs will be executed and traced
with the correct effective privileges.
Since only users trusted with full root privileges should be allowed
to do these things,
it only makes sense to install
.B strace
as setuid to root when the users who can execute it are restricted
to those users who have this trust.
For example, it makes sense to install a special version of
.B strace
with mode 'rwsr-xr--', user
.B root
and group
.BR trace ,
where members of the
.B trace
group are trusted users.
If you do use this feature, please remember to install
a non-setuid version of
.B strace
for ordinary lusers to use.
.SH NOTES
It is a pity that so much tracing clutter is produced by systems
employing shared libraries.
.LP
It is instructive to think about system call inputs and outputs
as data-flow across the user/kernel boundary.  Because user-space
and kernel-space are separate and address-protected, it is
sometimes possible to make deductive inferences about process
behavior using inputs and outputs as propositions.
.LP
In some cases, a system call will differ from the documented behavior
or have a different name.  For example, the
.BR faccessat (2)
system call does not have
.I flags
argument, and the
.BR setrlimit (2)
library function uses
.BR prlimit (2)
system call on modern (2.6.38+) kernels.  These
discrepancies are normal but idiosyncratic characteristics of the
system call interface and are accounted for by C library wrapper
functions.
.LP
Some system calls have different names in different architectures and
personalities.  In these cases, system call filtering and printing
uses the names that match corresponding
.BR __NR_ *
kernel macros of the tracee's architecture and personality.
There are two exceptions from this general rule:
.BR arm_fadvise64_64 (2)
ARM syscall and
.BR xtensa_fadvise64_64 (2)
Xtensa syscall are filtered and printed as
.BR fadvise64_64 (2).
.LP
On some platforms a process that is attached to with the
.B \-p
option may observe a spurious EINTR return from the current
system call that is not restartable.  (Ideally, all system calls
should be restarted on strace attach, making the attach invisible
to the traced process, but a few system calls aren't.
Arguably, every instance of such behavior is a kernel bug.)
This may have an unpredictable effect on the process
if the process takes no action to restart the system call.
.SH BUGS
Programs that use the
.I setuid
bit do not have
effective user
.SM ID
privileges while being traced.
.LP
A traced process runs slowly.
.LP
Traced processes which are descended from
.I command
may be left running after an interrupt signal (\c
.SM CTRL\s0-C).
.SH HISTORY
The original
.B strace
was written by Paul Kranenburg
for SunOS and was inspired by its trace utility.
The SunOS version of
.B strace
was ported to Linux and enhanced
by Branko Lankester, who also wrote the Linux kernel support.
Even though Paul released
.B strace
2.5 in 1992,
Branko's work was based on Paul's
.B strace
1.5 release from 1991.
In 1993, Rick Sladkey merged
.B strace
2.5 for SunOS and the second release of
.B strace
for Linux, added many of the features of
.BR truss (1)
from SVR4, and produced an
.B strace
that worked on both platforms.  In 1994 Rick ported
.B strace
to SVR4 and Solaris and wrote the
automatic configuration support.  In 1995 he ported
.B strace
to Irix
and tired of writing about himself in the third person.
.SH REPORTING BUGS
Problems with
.B strace
should be reported to the
.B strace
mailing list at <strace\-devel@lists.sourceforge.net>.
.SH "SEE ALSO"
.BR ltrace (1),
.BR time (1),
.BR ptrace (2),
.BR proc (5)
